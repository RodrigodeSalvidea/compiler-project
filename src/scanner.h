#include "./nextChar.h"
#include "./transitions.h"
#include <string.h>
#include "matchHexChar.h"

#ifndef SCANNER_DEFINITIONS
#define SCANNER_DEFINITIONS

typedef signed char Sign;
#define POSITIVE 1
#define NEGATIVE -1
int scan(int inFD, int outFD, int stringOut);
#define ACCEPTING 0x4000
enum e_State{
	STATE_INITIAL = 1,
	STATE_ERROR = 2,
	STATE_ONE_ZERO	= ACCEPTING | 3,
	STATE_LEADING_ZEROS = ACCEPTING | 4,
	STATE_INIT_BINARY = 5,
	STATE_INIT_HEX = 6,
	STATE_ACCEPT_HEX = ACCEPTING | 7,
	STATE_ACCEPT_OCTAL = ACCEPTING | 8,
	STATE_ACCEPT_DECIMAL   = ACCEPTING | 9,
	STATE_MINUS         = 10,
	STATE_INIT_DEC_FLOAT = 11,
	STATE_INIT_HEX_FLOAT = 12,
	STATE_ACCEPT_STRING = ACCEPTING | 13,
	STATE_INIT_STRING = 14,
	STATE_ACCEPT_DEC_FLOAT = ACCEPTING | 15,
	STATE_ACCEPT_HEX_FLOAT = ACCEPTING | 16,
	STATE_ACCEPT_NAME = ACCEPTING | 17,
	STATE_ACCEPT_BINARY = ACCEPTING | 18,
	STATE_ACCEPT_FULLSTOP = ACCEPTING | 19,
        STATE_ACCEPT_SEMICOLON = ACCEPTING | 20,
	STATE_ACCEPT_PLUS = ACCEPTING | 21,
	STATE_ACCEPT_PLUSPLUS = ACCEPTING |22,
	STATE_ACCEPT_PLUSEQUALS = ACCEPTING | 23,
	STATE_ACCEPT_MINUSMINUS = ACCEPTING | 24,
	STATE_ACCEPT_MINUSEQUALS = ACCEPTING | 25,
	STATE_ACCEPT_ASSIGN = ACCEPTING | 26,
	STATE_ACCEPT_EQUALS = ACCEPTING | 27,
	STATE_ACCEPT_NEQUALS = ACCEPTING | 28,
	STATE_ACCEPT_NOT = ACCEPTING | 29,
	STATE_ACCEPT_GREATERTHAN = ACCEPTING | 30,
	STATE_ACCEPT_LESSTHAN = ACCEPTING | 31,
	STATE_ACCEPT_LEQ = ACCEPTING | 32,
	STATE_ACCEPT_GEQ = ACCEPTING | 33,
	STATE_ACCEPT_COLON = ACCEPTING | 34,
	STATE_ACCEPT_BITOR = ACCEPTING | 35,
	STATE_ACCEPT_BITAND = ACCEPTING | 36,
	STATE_ACCEPT_LOGICALOR = ACCEPTING | 37,
	STATE_ACCEPT_LOGICALAND = ACCEPTING | 38,
	STATE_ACCEPT_LPAREN = ACCEPTING | 39,
	STATE_ACCEPT_RPAREN = ACCEPTING | 40,
	STATE_ACCEPT_LCURLY = ACCEPTING | 41,
	STATE_ACCEPT_RCURLY = ACCEPTING | 42,
	STATE_ACCEPT_LSQUARE = ACCEPTING | 43,
	STATE_ACCEPT_RSQUARE = ACCEPTING | 44,
	STATE_ACCEPT_COMPLEMENT = ACCEPTING | 45,
	STATE_ACCEPT_XOR = ACCEPTING | 46,
	STATE_ACCEPT_MOD = ACCEPTING | 47,
	STATE_ACCEPT_MODEQUALS = ACCEPTING | 48,
	STATE_ACCEPT_STAR = ACCEPTING | 49,
	STATE_ACCEPT_TIMESEQUALS = ACCEPTING | 50,
	STATE_ACCEPT_AMPERSAND = ACCEPTING | 51,
	STATE_ACCEPT_MINUS = ACCEPTING | 52,
	STATE_ACCEPT_COMMA = ACCEPTING | 53,
	STATE_ACCEPT_FSLASH = ACCEPTING | 54,
	STATE_ACCEPT_FSLASHEQUALS = ACCEPTING | 55,
	STATE_ACCEPT_LEFTSHIFT = ACCEPTING | 56,
	STATE_ACCEPT_RIGHTSHIFT = ACCEPTING | 57,
	STATE_ACCEPT_QUESTION = ACCEPTING | 58,
	STATE_ACCEPT_ARROW = ACCEPTING | 59,
	STATE_ESCAPE_STRING = 60,
	STATE_FIRST_OCTAL_ESCAPE_DIG = 61,
	STATE_SECOND_OCTAL_ESCAPE_DIG = 62,
	STATE_THIRD_OCTAL_ESCAPE_DIG = 63,
	STATE_INIT_HEX_ESCAPE = 63,
	STATE_FIRST_HEX_ESCAPE_DIG = 64,
	STATE_SECOND_HEX_ESCAPE_DIG = 65,
	STATE_INIT_CHAR = 66,
	STATE_REGCHAR = 67,
	STATE_ESCAPE_CHAR = 68,
	STATE_INIT_HEX_CHAR_ESCAPE = 69,
	STATE_FIRST_HEX_CHAR_ESCAPE = 70,
	STATE_SECOND_HEX_CHAR_ESCAPE = 71,
	STATE_FIRST_OCTAL_CHAR_ESCAPE = 72,
	STATE_SECOND_OCTAL_CHAR_ESCAPE = 73,
	STATE_THIRD_OCTAL_CHAR_ESCAPE = 74,
	STATE_ACCEPT_CHAR = ACCEPTING | 75,
	};
//
//words that will be keywords:
//break
//case
//char
//continue
//default
//do
//double
//else
//enum
//float
//for
//goto
//if
//int
//long
//register
//return
//short
//unsigned
//sizeof
//static
//struct
//switch
//union
//unsigned
//void
//while
typedef enum e_State State;

#define STRING_BUFFER_LENGTH 0x1000
union U_monadValue{
  unsigned int offset;
  double floatVal;
  long intVal;
};
typedef union U_monadValue MonadValue;

enum e_TokenType{
	INT_TOKEN,
	FLOAT_TOKEN,
	NAME_TOKEN,
   	STRING_TOKEN,
	EMPTY_TOKEN,
	FULLSTOP_TOKEN,
	ASSIGN_TOKEN,
	COMMA_TOKEN,
	PLUS_TOKEN,
	MINUS_TOKEN,
	STAR_TOKEN,
	FSLASH_TOKEN,
	MOD_TOKEN,
	PLUSEQUALS_TOKEN,
	MINUSEQUALS_TOKEN,
	FSLASHEQUALS_TOKEN,	
	MODEQUALS_TOKEN,
	TIMESEQUALS_TOKEN,
	PLUSPLUS_TOKEN,
	MINUSMINUS_TOKEN,
	GREATERTHAN_TOKEN,
	LESSTHAN_TOKEN,
	GEQ_TOKEN,
	LEQ_TOKEN,
	EQUALS_TOKEN,
	NEQUALS_TOKEN,
	SEMICOLON_TOKEN,
	COLON_TOKEN,
	LPAREN_TOKEN,
	RPAREN_TOKEN,
	LSQUARE_TOKEN,
	RSQUARE_TOKEN,
	LCURLY_TOKEN,
	RCURLY_TOKEN,
	NOT_TOKEN,
	BITOR_TOKEN,
	BITAND_TOKEN,
	LOGICALAND_TOKEN,
	LOGICALOR_TOKEN,
	COMPLEMENT_TOKEN,
	XOR_TOKEN,
	AMPERSAND_TOKEN,
	LEFTSHIFT_TOKEN,
	RIGHTSHIFT_TOKEN,
	QUESTION_TOKEN,
	ARROW_TOKEN,
	CHAR_TOKEN,
	BREAK_KEYWORD_TOKEN,
	CASE_KEYWORD_TOKEN,
	CONTINUE_KEYWORD_TOKEN,
	CHAR_KEYWORD_TOKEN,
	DO_KEYWORD_TOKEN,
	DEFAULT_KEYWORD_TOKEN,
	DOUBLE_KEYWORD_TOKEN,
	ELSE_KEYWORD_TOKEN,
	ENUM_KEYWORD_TOKEN,
	FLOAT_KEYWORD_TOKEN,
	FOR_KEYWORD_TOKEN,
	GOTO_KEYWORD_TOKEN,
	IF_KEYWORD_TOKEN,
	INT_KEYWORD_TOKEN,
	LONG_KEYWORD_TOKEN,
	REGISTER_KEYWORD_TOKEN,
	RETURN_KEYWORD_TOKEN,
	SHORT_KEYWORD_TOKEN,
	UNSIGNED_KEYWORD_TOKEN,
	SIZEOF_KEYWORD_TOKEN,
	STATIC_KEYWORD_TOKEN,
	STRUCT_KEYWORD_TOKEN,
	SWITCH_KEYWORD_TOKEN,
	UNION_KEYWORD_TOKEN,
	VOID_KEYWORD_TOKEN,
	WHILE_KEYWORD_TOKEN



};
typedef enum e_TokenType TokenType;

struct s_monad{
  TokenType type;
  MonadValue value;
  size_t size;
};
typedef struct s_monad Monad;
#endif
